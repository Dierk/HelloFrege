module TypeClassForWrapper where

{--
    Make a variant of TypeClassExample where the calculation with 
    Metrics is type safe, i.e. one cannot mix Metric calculations with plain numbers -
    except Int, which serves as the base unit (see fromInt).
--}


data Millimeter = MM Int

data Seconds = SEC Int

-- would be nice, if we could "derive" Num

instance Num Millimeter where
    zero = MM 0
    one  = MM 1
    (MM a) + (MM b) = MM (a+b)
    (MM a) - (MM b) = MM (a-b)
    (MM a) * (MM b) = MM (a*b)
    MM a  <=> MM b  = a <=> b
    hashCode (MM a) = hashCode a
    fromInt     a   = MM a
    fromInteger a   = MM a.fromIntegral
    
instance Num Seconds where
    zero = SEC 0
    one  = SEC 1
    (SEC a) + (SEC b) = SEC (a+b)
    (SEC a) - (SEC b) = SEC (a-b)
    (SEC a) * (SEC b) = SEC (a*b)
    SEC a  <=> SEC b  = a <=> b
    hashCode (SEC a)  = hashCode a
    fromInt     a     = SEC a
    fromInteger a     = SEC a.fromIntegral    

class (Integral a)  => Metric a  where
    mm :: a -> Millimeter
    cm :: a -> Millimeter
    m  :: a -> Millimeter

class (Integral a)  => Time a  where
    sec :: a -> Seconds
    minutes :: a -> Seconds
    h   :: a -> Seconds
    
class (Real a)  => Unit a  where
    kmh :: a -> Velocity

instance Metric Int where
    mm i = MM i
    cm i = i.mm * 10   
    m  i = i.cm * 100  
    
instance Time Int where
    sec     i = SEC i
    minutes i = i.sec * 60   
    h       i = i.minutes * 60  

instance Unit Double where
    kmh val = KMH val

data Velocity = KMH Double
derive Eq   Velocity
derive Show Velocity

per (MM mm) (SEC sec) = KMH (( mm.fromIntegral / sec.fromIntegral) * 0.0036) 

main args = do
    println $ MM 10 + MM 10 == MM 20
    println $ 10.m - 20.cm + 10.mm - 3.cm         == 9780.mm
    println $ 10.m - 20.cm + 10.mm - 3.cm + 3     == 9783.mm  
    println $ 3.sec + 1.h - 30.minutes + 3        == 1806.sec
    println $ (3.m * 500) `per` (3000.sec + 600)  == 1.5.kmh    

